# Part 06：資料集合與迴圈迭代

[回到目錄](https://github.com/alankrantas/learn-python-on-microbit-guide/blob/main/README.md)

## 資料的集合

在程式中能用變數記錄資料很方便，但當資料量變多時，管理上就會更麻煩。Python 提供了幾種形式的集合（collection）讓我們整理資料，而且可以用迴圈去批次處理它們。在 Python 中，這通常會用 for 迴圈來做。

舉個例子，若我們想讓 micro:bit 播放一系列預定的音符：

```python
from microbit import sleep
import music

music.pitch(587)
sleep(500)

music.pitch(659)
sleep(500)

music.pitch(523)
sleep(500)

music.pitch(262)
sleep(500)

music.pitch(392)
sleep(1500)

music.stop()
```

這樣看來很好，但你會發現每個動作其實大同小異，只有音的頻率不同而已。能不能把這些動作簡化成同一個動作呢？

## Python 基礎：串列（list）集合

### 建立和使用串列

在 Python 的集合當中，最基本也最常用的集合叫做**串列（list）**。下面宣告了個變數 lst，其內容是個含有 5 筆資料的串列：

```
>>> lst = [1, 2, 3, 4, 5]
>>> lst
[1, 2, 3, 4, 5]
```

串列的資料用中括號 ```[]``` 包住，每一筆資料之間用半形逗號隔開。每一筆資料稱為串列的元素（element），而串列也可被稱為是個容器（container）。

串列就是 list 型別：

```
>>> type(lst)
<class 'list'>
```

串列當中的元素, 可以用 ```串列名稱[索引]``` 的方式讀取或修改之：

```
>>> lst[0]
1
>>> lst[2]
3
>>> lst[4] = 10
>>> lst[4]
10
>>> lst
[1, 2, 3, 4, 10]
```

每個元素其實都是一個變數。索引一定是從 0 開始，這是電腦系統一個長久以來就存在的習慣。以這個串列為例, 它有 5 個元素, 所以最後一個元素的索引就會是元素的總數（或串列長度）減 1。

### 串列與其元素的關係

注意到串列元素會有自己的型別：

```
>>> type(lst[0])
<class 'int'>
```

也就是說，串列雖然有自己的型別，但它裡面的元素卻是各自不同的變數，指向整數型別的數字。

記得在 Part 2 時，我們提過 Python 變數是個路標，它指向資料而不是儲存資料。這裡我們就要來看一下這種特質對於串列的奇特影響。下面我們建立一個串列，然後建立另一個串列來「複製」它。接著我們修改其中一個串列的元素值，猜猜看會發生什麼事？

```
>>> lst1 = [1, 2, 3]
>>> lst2 = lst1
>>> lst2[0] *= 10
>>> lst1
[10, 2, 3]
```

兩個串列的索引 0 元素一起改變了。這自然是因為兩個串列變數指向了同一個 list 型別物件，所以它們的元素就是共用的。

雖然你目前會這樣「複製」串列的場合還不多，但你事先不曉得 Python 變數是這種性質的話，就可能會遇到讓你不得其解的狀況了。之後我們也會提到如何真正複製出一個串列，使兩個串列變成分離的物件。

### 串列可以儲存任何型別及數量的元素

Python 串列的元素不見得只能儲存同樣型別的元素，甚至可以是另一個串列：

```
>>> lst = [1, 3.14159, ['Hello World', True, None]]
>>> lst
[1, 3.14159, ['Hello World', True, None]]
```

如果想取出子串列的值，只要先取出該子串列，再存取其元素即可：

```
>>> lst[2][0]
'Hello World'
```

元素的型別取決於它的值。例如，```lst[1]``` 是浮點數型別，```lst[2]``` 是個串列，而 ```lst[2][0]``` 則是個字串。

> 在其他程式語言中會有陣列（array），但陣列是長度固定、也只能儲存同一種資料型別的集合。Python 不是沒有陣列，但它最主要和最常用的集合就是串列。話說回來，在串列中混和放不同類型的資料，有時也只會把事情搞複雜而已。

串列也可以是空串列（沒有元素）：

```
>>> lst_empty = []
>>> lst_empty
[]
```

Python 串列非常有彈性，你也能在宣告它之後任意增減元素。之後我們會再談到這點。

## 改寫音符清單

現在，我們回頭來用串列改寫一開始的音符播放程式：

```python
from microbit import sleep
import music

notes = [587, 659, 523, 262, 392]
delay = [500, 500, 500, 500, 1500]

music.pitch(notes[0])
sleep(delay[0])

music.pitch(notes[1])
sleep(delay[1])

music.pitch(notes[2])
sleep(delay[2])

music.pitch(notes[3])
sleep(delay[3])

music.pitch(notes[4])
sleep(delay[4])

music.stop()
```

看起來似乎沒有變得更簡短，頂多只是把數值收集到了同一個位置而已。能不能把程式變得更精簡呢？

## Python 基礎：for 迴圈

### 迭代集合元素

之前在講 while 迴圈時，迴圈每次執行都稱為一次迭代（iteration）。不過在 Python 中，從集合逐次取值的動作也稱為是迭代。也就是說，你可以用迴圈去逐次取出集合的元素，而且將這些動作簡化成桐一個。

此外，許多程式語言都有 for 迴圈，但 Python 的 for 迴圈是特別設計來做集合迭代的，這點卻是許多教材從一開始就講不清楚的事。

首先來看以下範例：

```python
for item in [1, 2, 3, 4, 5]:
    print(item)
```

執行結果為

```
1
2
3
4
5
```

簡單地說，for...in 會從串列一次讀出一個元素，放進 item 這個變數，然後把它印出來。當串列的所有值都取完以後，for 迴圈就會自行結束。Python 中其實有非常多東西可以用 for 來迭代，我們稱這些集合是可迭代的（iterable）。

和 if 與 while 敘述一樣，for 這句的結尾必須加上冒號，而迴圈內的程式碼則得向右縮排。

如果要在 while 迴圈做出一模一樣效果的話，你必須自己控制迴圈要執行幾次，感覺上就比較麻煩：

```python
lst = [1, 2, 3, 4, 5]

i = 0
while i < 5:
    print(lst[i])
    i += 1
```

### for 取出的值 vs. 串列元素

如果你嘗試在迴圈中更改變數 item 的值，會不會影響串列本身呢？

```python
lst = [1, 2, 3, 4, 5]

for item in lst:
    item *= 2
    print(item)

print(lst)
```

既然 Python 變數是路牌，當你把它指向新的值時，就不再會指向串列元素了。所以若你想修改原始串列的值，直接改變 item 變數是沒用的。

> 當然也不是說真的沒用──要是元素本身是個串列，而你修改該串列元素指向的值，那當然就會影響到原本的子元素串列了。但你會這麼做的機會並不多。

另一個有趣但不見得有用的小細節是，item 變數在 for 迴圈結束後仍然會存在，它會儲存著在迴圈中最後一個取出的元素。

### 用索引來迭代集合

如果想在迴圈修改串列的元素，你得用```串列名稱[索引]``` 的語法才行。如果不要用 while 來寫，該怎麼產生索引來讓 for 迭代？

也許可以像這樣：

```python
lst = [1, 2, 3, 4, 5]

for i in [0, 1, 2, 3, 4]:
    lst[i] *= 2

print(lst)
```

執行結果如下：

```
[2, 4, 6, 8, 10]
```

換言之，for 迴圈現在迭代的是另一個串列，其值剛好對應到 lst 的每個索引，但這樣寫並不是很方便。如果你的串列有上百個元素呢？

這時我們可以使用 **range()** 函式來替我們產生索引數列：

```
>>> range(5)
range(0, 5)
>>> list(range(5))
[0, 1, 2, 3, 4]
```

range(n) 函式傳回的東西不是串列，而是個型別為 range 的集合，其元素為整數 0 到 n-1，剛好對應到有 n 個元素的串列的索引。

你可以看到，我們必須用 list() 把 range 數列轉換成串列才看得到內容，不過 for 迴圈是可以直接迭代 range 集合的。因此你能把程式改寫如下：

```python
lst = [1, 2, 3, 4, 5]

for i in range(5):
    lst[i] *= 2

print(lst)
```

幾乎所有的 Python 教材都會先從 for ... in range ... 講起，而對於學過 C 或 Java 等語言的人來說，他們就非常容易跟後者的計數器迴圈混淆。

### 自動判斷集合長度

上面程式的缺點是，你必須在 range() 指定正確的串列長度。要是長度不對，就會得到錯的結果：

```python
lst = [1, 2, 3, 4, 5]

print('Try 1...')

for i in range(3):
    print(lst[i])

print('Try 2...')

for i in range(6):
    print(lst[i])
```

```
Try 1...
1
2
3
Try 2...
1
2
3
4
5
Traceback (most recent call last):
  File "<stdin>", line 11, in <module>
IndexError: list index out of range
```

第一次的 for 迴圈只數到索引 2（第 3 個元素），而第二次 for 迴圈嘗試存取 ```lst[5]``` 時產生了「索引超出範圍」錯誤。

Python 內建函式 **len()** 可傳回串列的長度：

```
>>> lst = [1, 2, 3, 4, 5]
>>> len(lst)
5
```

進一步改寫程式如下：

```python
lst = [1, 2, 3, 4, 5]

for i in range(len(lst)):
    lst[i] *= 2

print(lst)
```

這麼一來不管 lst 實際上有多少元素，不管你怎麼修改串列的定義，for 迴圈都能正確無誤處理到所有元素了。

## 再次改寫音符清單

最後我們就來運用串列和 for 迴圈，把一開始的程式寫成更漂亮的版本。

由於我們其實一次要處理兩個串列（音符頻率及延遲時間），所以第一個版本先用 range()，以便取得相同的索引：

```python
from microbit import sleep
import music

notes = [587, 659, 523, 262, 392]
delay = [500, 500, 500, 500, 1500]

for i in range(5):
    music.pitch(notes[i])
    sleep(delay[i])

music.stop()
```

只要你能把問題用程式的角度去解構，將共通的邏輯抽取出來，就能用省力又漂亮的方式解決問題。Python 串列與 for 迴圈正是能大幅簡化資料處理的實用工具。

下面是不使用 range() 的辦法，這回我們把頻率跟延遲時間寫在同一個串列中，每個元素變成了 ```[頻率, 毫秒]``` 的格式：

```python
from microbit import sleep
import music

notes = [
    [587, 500],
    [659, 500],
    [523, 500],
    [262, 500],
    [392, 1500],
    ]

for note in notes:
    music.pitch(note[0])
    sleep(note[1])

music.stop()
```

這裡可以看到，串列內容、包括結束的中括號都是可以照逗點分行寫的（怎麼縮排則無所謂），連最後一個元素後面都可以加上逗號。在某些時候，這麼寫有助於增進程式的閱讀性。

其實 for 迴圈還能有很多變化，這些我們後面有機會再來討論。
